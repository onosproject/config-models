// Code generated by model-compiler. DO NOT EDIT.

// SPDX-FileCopyrightText: 2022-present Intel Corporation
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"context"
	"github.com/onosproject/config-models/models/ric/api"
    "github.com/onosproject/config-models/pkg/path"
	"github.com/onosproject/config-models/pkg/xpath/navigator"
	"github.com/onosproject/onos-api/go/onos/config/admin"
	"github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/onosproject/onos-lib-go/pkg/logging"
	"github.com/onosproject/onos-lib-go/pkg/northbound"
	"github.com/openconfig/ygot/ygot"
	"google.golang.org/grpc"
	"io"
	"os"
	"strconv"
)

var log = logging.GetLogger("plugin")

type modelPlugin struct {
}

type server struct {
}

// gRPC path lists; derived from native path maps
var roPaths []*admin.ReadOnlyPath
var rwPaths []*admin.ReadWritePath
var namespaceMappings []*admin.Namespace

func (p *modelPlugin) Register(gs *grpc.Server) {
	log.Info("Registering model plugin service")
	server := &server{}
	admin.RegisterModelPluginServiceServer(gs, server)
}

func main() {
	ready := make(chan bool)

	if len(os.Args) < 2 {
		log.Fatal("gRPC port argument is required")
		os.Exit(1)
	}

	i, err := strconv.ParseInt(os.Args[1], 10, 16)
	if err != nil {
		log.Fatal("specified gRPC port is invalid", err)
		os.Exit(1)
	}
	port := int16(i)

	entries, err := api.UnzipSchema()
	if err != nil {
		log.Fatalf("Unable to extract model schema: %+v", err)
	}
	roPaths, rwPaths, namespaceMappings = path.ExtractPaths(entries)

	// Start gRPC server
	log.Info("Starting model plugin")
	p := modelPlugin{}
	if err := p.startNorthboundServer(port); err != nil {
		log.Fatal("Unable to start model plugin service", err)
	}

	// Serve
	<-ready
}

func (p *modelPlugin) startNorthboundServer(port int16) error {
	cfg := northbound.NewServerConfig("", "", "", port, true)
	s := northbound.NewServer(cfg)

	s.AddService(p)

	doneCh := make(chan error)
	go func() {
		err := s.Serve(func(started string) {
			log.Info("Started NBI on ", started)
			close(doneCh)
		})
		if err != nil {
			doneCh <- err
		}
	}()
	return <-doneCh
}

func (s server) GetModelInfo(ctx context.Context, request *admin.ModelInfoRequest) (*admin.ModelInfoResponse, error) {
	log.Infof("Received model info request: %+v", request)
	return &admin.ModelInfoResponse{
		ModelInfo: &admin.ModelInfo{
			Name:               "ric",
			Version:            "1.0.0",
			ModelData:          api.ModelData(),
			SupportedEncodings: api.Encodings(),
			GetStateMode:       0,
			ReadOnlyPath:       roPaths,
			ReadWritePath:      rwPaths,
            NamespaceMappings:    namespaceMappings,
            SouthboundUsePrefix:  false,
		},
	}, nil
}

func (s server) ValidateConfig(ctx context.Context, request *admin.ValidateConfigRequest) (*admin.ValidateConfigResponse, error) {
	log.Infof("Received validate config request: %s", request.String())
	gostruct, err := s.unmarshallConfigValues(request.Json)
	if err != nil {
		return nil, errors.Status(err).Err()
	}

	if err := s.validate(gostruct); err != nil {
		return nil, errors.Status(err).Err()
	}

	if err := s.validateMust(*gostruct); err != nil {
		return nil, errors.Status(err).Err()
	}
	return &admin.ValidateConfigResponse{Valid: true}, nil
}

func (s server) ValidateConfigChunked(srv admin.ModelPluginService_ValidateConfigChunkedServer) error {
	var response []byte
	for {
		c, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				log.Debugf("Validating JSON config of %d bytes", len(response))
				gostruct, err := s.unmarshallConfigValues(response)
				if err != nil {
					return errors.Status(err).Err()
				}
				if err := s.validate(gostruct); err != nil {
					return errors.Status(err).Err()
				}
				if err := s.validateMust(*gostruct); err != nil {
					return errors.Status(err).Err()
				}
				return srv.SendAndClose(&admin.ValidateConfigResponse{
					Valid: true,
				})
			}
			return err
		}
		response = append(response, c.GetJson()...)
	}
	return nil
}

func (s server) GetPathValues(ctx context.Context, request *admin.PathValuesRequest) (*admin.PathValuesResponse, error) {
	log.Infof("Received path values request: %+v", request)
	pathValues, err := path.GetPathValues(request.PathPrefix, request.Json)
	if err != nil {
		return nil, errors.Status(errors.NewInvalid("Unable to get path values: %+v", err)).Err()
	}
	return &admin.PathValuesResponse{PathValues: pathValues}, nil
}

func (s server) GetValueSelection(ctx context.Context, request *admin.ValueSelectionRequest) (*admin.ValueSelectionResponse, error) {
	log.Infof("Received value selection request: %s", request.String())
	device, err := s.unmarshallConfigValues(request.ConfigJson)
	if err != nil {
		return nil, errors.Status(err).Err()
	}
	schema, err := api.Schema()
	if err != nil {
		return nil, errors.NewInvalid("Unable to get schema: %+v", err)
	}

	nn := navigator.NewYangNodeNavigator(schema.RootSchema(), *device, true)
	ynn, ok := nn.(*navigator.YangNodeNavigator)
	if !ok {
		return nil, errors.NewInvalid("Cannot cast NodeNavigator to YangNodeNavigator")
	}
	if err := ynn.NavigateTo(request.SelectionPath); err != nil {
		return nil, errors.NewInvalid("Unable to navigate to %s", request.SelectionPath)
	}

	results, err := ynn.LeafSelection()
	if err != nil {
		return nil, errors.NewInvalid("error getting leaf-selection", err)
	}

	return &admin.ValueSelectionResponse{
		Selection: results,
	}, nil
}

func (s server) GetValueSelectionChunked(srv admin.ModelPluginService_GetValueSelectionChunkedServer) error {
	var response []byte
	var selectionPath string
	for {
		c, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				log.Debugf("Transfer of %d bytes successful", len(response))
				device, err := s.unmarshallConfigValues(response)
				if err != nil {
					return errors.Status(err).Err()
				}
				schema, err := api.Schema()
				if err != nil {
					return errors.Status(errors.NewInvalid("Unable to get schema: %+v", err)).Err()
				}

				nn := navigator.NewYangNodeNavigator(schema.RootSchema(), *device, true)
				ynn, ok := nn.(*navigator.YangNodeNavigator)
				if !ok {
					return errors.Status(errors.NewInvalid("Cannot cast NodeNavigator to YangNodeNavigator")).Err()
				}
				if err := ynn.NavigateTo(selectionPath); err != nil {
					return errors.Status(errors.NewInvalid("Unable to navigate to selection. %+v", err)).Err()
				}

				results, err := ynn.LeafSelection()
				if err != nil {
					return errors.Status(errors.NewInvalid("error getting leaf-selection", err)).Err()
				}


				return srv.SendAndClose(&admin.ValueSelectionResponse{
					Selection: results,
				})
			}
			return err
		}
		selectionPath = c.GetSelectionPath() // We
		response = append(response, c.GetConfigJson()...)
	}
	return nil
}

func (s server) unmarshallConfigValues(jsonTree []byte) (*ygot.ValidatedGoStruct, error) {
	device := &api.Device{}
	vgs := ygot.ValidatedGoStruct(device)
	if err := api.Unmarshal([]byte(jsonTree), device); err != nil {
		return nil, errors.NewInvalid("Unable to unmarshal JSON: %+v", err)
	}
	return &vgs, nil
}

func (s server) validate(ygotModel *ygot.ValidatedGoStruct, opts ...ygot.ValidationOption) error {
	deviceDeref := *ygotModel
	device, ok := deviceDeref.(*api.Device)
	if !ok {
		return errors.NewInvalid("Unable to convert model ric-1.0.0")
	}
	return device.Validate()
}

func (s server) validateMust(device ygot.ValidatedGoStruct) error {
	log.Infof("Received validateMust request for device: %v", device)
	schema, err := api.Schema()
	if err != nil {
		return errors.NewInvalid("Unable to get schema: %+v", err)
	}

	nn := navigator.NewYangNodeNavigator(schema.RootSchema(), device, true)
	ynn, ok := nn.(*navigator.YangNodeNavigator)
	if !ok {
		return errors.NewInvalid("Cannot cast NodeNavigator to YangNodeNavigator")
	}
	return ynn.WalkAndValidateMust()
}

