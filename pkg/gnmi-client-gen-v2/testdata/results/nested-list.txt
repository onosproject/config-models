/*
* SPDX-FileCopyrightText: 2022-present Intel Corporation
*
* SPDX-License-Identifier: Apache-2.0
*/

// Generated via gnmi-gen.go, do NOT edit

package api

import (
    "context"
    "fmt"
    "github.com/onosproject/config-models/pkg/gnmi-client-gen/gnmi_utils"
    "github.com/openconfig/gnmi/proto/gnmi"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "reflect"
    "time"
)

type GnmiClient struct {
    client gnmi.GNMIClient
}

func NewTestGnmiClient(conn *grpc.ClientConn) *GnmiClient {
    gnmi_client := gnmi.NewGNMIClient(conn)
    return &GnmiClient{client: gnmi_client}
}

func (c *GnmiClient) Get_List(ctx context.Context, target string, list_list_leaf string,
) (*Test_List, error) {
	gnmiCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	path := []*gnmi.Path{
		{
			Elem: []*gnmi.PathElem{
				{
					Name: "list",
					Key: map[string]string{
						"list_list_leaf": fmt.Sprint(list_list_leaf),
					},
				},
			},
			Target: target,
		},
	}

	req := &gnmi.GetRequest{
		Encoding: gnmi.Encoding_JSON,
		Path:     path,
	}
	res, err := c.client.Get(gnmiCtx, req)

	if err != nil {
		return nil, err
	}

	val, err := gnmi_utils.GetResponseUpdate(res)

	if err != nil {
		return nil, err
	}

	json := val.GetJsonVal()
	st := Device{}
	Unmarshal(json, &st)

	if reflect.ValueOf(st.List).Kind() == reflect.Ptr && reflect.ValueOf(st.List).IsNil() {
		return nil, status.Error(codes.NotFound, "List-not-found")
	}
	if res, ok := st.List[list_list_leaf]; ok {
		return res, nil
	}

	return nil, status.Error(codes.NotFound, "List-not-found")
}

func (c *GnmiClient) Get_List(ctx context.Context, target string, list_list_leaf string, nestedList_nested_list_leaf uint16,
) (*Test_Nestedlist, error) {
	gnmiCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	path := []*gnmi.Path{
		{
			Elem: []*gnmi.PathElem{
				{
					Name: "list",
					Key: map[string]string{
						"list_list_leaf": fmt.Sprint(list_list_leaf),
					},
				},
				{
                    Name: "nestedList",
                    Key: map[string]string{
                        "nestedList_nested_list_leaf": fmt.Sprint(nestedList_nested_list_leaf),
                    },
                },
			},
			Target: target,
		},
	}

	req := &gnmi.GetRequest{
		Encoding: gnmi.Encoding_JSON,
		Path:     path,
	}
	res, err := c.client.Get(gnmiCtx, req)

	if err != nil {
		return nil, err
	}

	val, err := gnmi_utils.GetResponseUpdate(res)

	if err != nil {
		return nil, err
	}

	json := val.GetJsonVal()
	st := Device{}
	Unmarshal(json, &st)

	if reflect.ValueOf(st.List).Kind() == reflect.Ptr && reflect.ValueOf(st.List).IsNil() {
		return nil, status.Error(codes.NotFound, "List-not-found")
	}
	if res, ok := st.List[list_list_leaf].Test_Nestedlist[nestedList_nested_list_leaf]; ok {
		return res, nil
	}

	return nil, status.Error(codes.NotFound, "List-not-found")
}