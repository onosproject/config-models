// Copyright 2020-present Open Networking Foundation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package compiler

import (
	"fmt"
	api "github.com/onosproject/onos-api/go/onos/config/admin"
	"github.com/onosproject/onos-lib-go/pkg/logging"
	_ "github.com/openconfig/gnmi/proto/gnmi" // gnmi
	_ "github.com/openconfig/goyang/pkg/yang" // yang
	_ "github.com/openconfig/ygot/genutil"    // genutil
	_ "github.com/openconfig/ygot/ygen"       // ygen
	_ "github.com/openconfig/ygot/ygot"       // ygot
	_ "github.com/openconfig/ygot/ytypes"     // ytypes
	_ "google.golang.org/protobuf/proto"      // proto
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

var log = logging.GetLogger("config-model", "compiler")

// NewCompiler creates a new config model compiler
func NewCompiler() *ModelCompiler {
	return &ModelCompiler{}
}

// ModelCompiler is a model plugin compiler
type ModelCompiler struct {
	metaData  *MetaData
	modelInfo *api.ModelInfo
}

// Compile compiles the config model
func (c *ModelCompiler) Compile(path string) error {
	log.Infof("Compiling config model at '%s'", path)
	var err error

	// Make sure inputs are present: meta-data file and YANG files directory
	// Read model meta-data
	err = c.loadModelMetaData(path)
	if err != nil {
		log.Errorf("Unable to read model meta-data: %+v", err)
		return err
	}

	// Generate Golang bindings for the YANG files
	err = c.generateGolangBindings(path)
	if err != nil {
		log.Errorf("Unable to generate Golang bindings: %+v", err)
		return err
	}

	// Generate YANG model tree
	err = c.generateModelTree(path)
	if err != nil {
		log.Errorf("Unable to generate YANG model tree: %+v", err)
		return err
	}

	// Generate model plugin artifacts from generic templates
	// - main
	// - gRPC PluginService NB
	// - model plugin Dockerfile from template
	err = c.generatePluginArtifacts(path)
	if err != nil {
		log.Errorf("Unable to generate model plugin artifacts: %+v", err)
		return err
	}

	// TODO: Generate OpenAPI for RBAC
	return nil
}

func (c *ModelCompiler) loadModelMetaData(path string) error {
	c.metaData = &MetaData{}
	if err := LoadMetaData(path, c.metaData); err != nil {
		return err
	}
	c.modelInfo = &api.ModelInfo{Name: c.metaData.Name, Version: c.metaData.Version}
	return nil
}

func (c *ModelCompiler) generateGolangBindings(path string) error {
	pkg := c.getModelPackage()
	file := filepath.Join(path, pkg, "generated.go")
	log.Infof("Generating YANG bindings '%s'", file)

	args := []string{
		"run",
		"github.com/openconfig/ygot/generator",
		fmt.Sprintf("-path=%s/yang", path),
		fmt.Sprintf("-output_file=%s", file),
		fmt.Sprintf("-package_name=%s", pkg),
		"-generate_fakeroot",
		"--include_descriptions",
	}

	// Append all YANG files to the command-line arguments
	files, err := ioutil.ReadDir(filepath.Join(path, "yang"))
	if err != nil {
		return err
	}
	for _, file := range files {
		args = append(args, file.Name())
	}

	log.Infof("Executing %s", path, strings.Join(args, " "))
	cmd := exec.Command("go", args...)
	cmd.Env = os.Environ()
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()

	// TODO: Add header prefix - // Code generated by YGOT. DO NOT EDIT.
}

func (c *ModelCompiler) generateModelTree(path string) error {
	treeFile := filepath.Join(path, c.modelInfo.Name + "-" + c.modelInfo.Version + ".tree")
	log.Infof("Generating YANG tree '%s'", treeFile)

	yangDir := filepath.Join(path, "yang")
	args := []string{"-f", "tree", "-p", yangDir, "-o", treeFile}

	// Append the root YANG files to the command-line arguments
	for _, yangFile := range c.metaData.YangFiles {
		args = append(args, filepath.Join(yangDir, yangFile))
	}

	log.Infof("Executing %s", path, strings.Join(args, " "))
	cmd := exec.Command("pyang", args...)
	cmd.Env = os.Environ()
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func (c *ModelCompiler) generatePluginArtifacts(path string) error {
	return nil
}

func (c *ModelCompiler) getModelPackage() string {
	return sanitized(c.modelInfo.Name) + "_" + sanitized(c.modelInfo.Version)
}

func sanitized(s string) string {
	return strings.ReplaceAll(strings.ReplaceAll(s, ".", "_"), "-", "_")
}
